# Spring Boot Components

[slide hideTitle]

# Spring Boot

[video src="https://videos.softuni.org/hls/Java/Java-Spring-Fundamentals/EN/Spring-Boot/01-Spring-Boot-,1080p,720p,480p,360p,240p,.mp4/urlset/master.m3u8" poster="" /]

**Spring Boot** is an open-source **Java framework**.

It allows developers to create multiple **independent** **services**.

**Spring Boot** has the following advantages:

- Easy to **configure**

- **Quick initialization** of a project

- **Less** development time

- **Higher** productivity

[/slide]

[slide hideTitle]

# Creating a Spring Boot Project

[video src="https://videos.softuni.org/hls/Java/Java-Spring-Fundamentals/EN/Spring-Boot/06-creating-spring-boot-project-,1080p,720p,480p,360p,240p,.mp4/urlset/master.m3u8" poster="" /]

A **Spring Boot Project** can be **automatically** generated by going to [https://start.spring.io/](https://start.spring.io/).

The website allows:

- **Choosing a programming language**

- **Using different project managers**

- **Adding dependencies**

- **Choosing different Spring Boot versions**

[image assetsSrc="Java-Spring-Boot-1.jpg" /]

[/slide]

[slide hideTitle]

# Spring Dev Tools

**Spring Boot** provides developers with the choice of installing **DevTools**.

As the name suggests, they ease the development process.

They save time by automatically **restarting** the application **on change**.

You can start using them by including the following Maven dependency:

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime<scope>
</dependency>
```

[/slide]

[slide hideTitle]

# Spring Resources

The **spring resources** folder consists of **three parts**:

- **static files** - mainly **HTML**, **CSS**, and **JavaScript**

- **templates** - **Thymeleaf** templates

- `application.properties` - the **configuration** file for the application

[image assetsSrc="Java-Spring-Boot-2.jpg" /]

[/slide]

[slide hideTitle]

# Spring Boot Main Components

[video src="https://videos.softuni.org/hls/Java/Java-Spring-Fundamentals/EN/Spring-Boot/09-spring-boot-main-components-,1080p,720p,480p,360p,240p,.mp4/urlset/master.m3u8" poster="" /]

The **Spring Boot** framework consists of the following **main components**:

- **Spring Boot Starters** - merge **related dependencies** into a **single dependency**

- **Spring Boot Auto-Configuration** - reduce **Spring Boot**'s configuration time to a minimum

- **Spring Boot CLI** - allows **development** in a **command-line** interface

- **Spring Boot Actuator** - used to **manage** an application. Provides **Endpoints**, **Metrics**, **Auditing** etc.

[/slide]

[slide hideTitle]

# Spring Boot Starters

As an application **expands**, it tends to have **more dependencies**.

Defining **every** single dependency is **slow** and **unproductive**.

A **Spring Boot Starter** consists of many **related dependencies**, combined into **one** `.jar` file.

After a **Starter** is added as a **dependency**, **Spring Boot** will **automatically load** all of its **dependencies** as well.

[image assetsSrc="Java-Spring-Boot-3.png" /]

[/slide]

[slide hideTitle]

# Spring Boot CLI

The **Spring Boot CLI** is a component that allows **development** and **testing** in the **command line**.

The **CLI** works with scripts written in a syntax similar to **Java code**.

To start the **CLI**, just type:

```java
spring
```

For more information about a given command, use:

```java
spring help init
```

After getting familiar with the **CLI** component, create a project wih the following code:

```java
$ spring init --dependencies=web,data-jpa car-store
Using service at https://start.spring.io
Project extracted to '/Users/developer/example/car-store'
```

[/slide]

[slide hideTitle]

# Spring Boot Actuator

The **Spring Boot Actuator** is used to get different kinds of information about an application.

Add the following **dependency** to use the **Actuator**:

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**Endpoints** are one of the **Actuator**'s main features.

They allow developers to "communicate" with their app through **HTTP** or **JMX**.

Some commonly used **Endpoints** are:

- `beans` - shows all **Spring beans** in the program

- `health` - displays the **health** of an application

- `metrics` - provides **metrics** for the application

The following image shows how to acces the **health endpoint**:

[image assetsSrc="Java-Spring-Boot-4.jpg" /]

[/slide]

[slide hideTitle]

# Inversion of Control

[video src="https://videos.softuni.org/hls/Java/Java-Spring-Fundamentals/EN/Spring-Boot/13-inversion-of-control-,1080p,720p,480p,360p,240p,.mp4/urlset/master.m3u8" poster="" /]


**Spring** implements the **Inversion of Control** principle and the **Dependency Injection** pattern.

**Inversion of Control** means switching the **flow of a program**.

In traditional applications, **libraries** are imported inside the **code** itself.

When using **IoC**, however, the **framework** calls **specific parts** of code that a **appropriate** for a certain **task**.

**Dependency Injection** is a **design pattern** that implements the **Inversion of Control**.

When this pattern is used, **dependencies** between **objects** are put in a **separate** **file**.

This practice **improves readability** and **reduces complexity**.

The following example shows how the **traditional** way of writing classes:

```java
public class UserServiceImpl implements UserService {
    private UserRepository userRepository = new UserRepository();
}
```

Now here is the same example, but using **Dependency Injection**:

```java
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserRepository userRepository;
}

```

[/slide]

[slide hideTitle]

# Spring IoC

The following image illustrates how the **Inversion of Control** happens in **Spring**:

[image assetsSrc="Java-Spring-Boot-5.png" /]

[/slide]

[slide hideTitle]

# Beans

**Beans** are the foundation of a **Spring** application.

They are **objects**, within an **IoC container**.

That container is responsible for **instantiating** and **managing** the **beans**.

Assume there is the following `Assistant` **class**:

```java
public class Assistant implements Employee {

    private String name;

    public Assistant() {}

    //Getter and Setter functions
}
```

This is how to declare a **bean**:

```java
@SpringBootApplication
public class MainApplication {

    â€¦

    @Bean
    public Employee getAssistant() {
        return new Assistant();
    }
}
```

[/slide]

[slide hideTitle]

# Getting a Bean from the Application Context

[video src="https://videos.softuni.org/hls/Java/Java-Spring-Fundamentals/EN/Spring-Boot/17-bean-from-application-context-,1080p,720p,480p,360p,240p,.mp4/urlset/master.m3u8" poster="" /]


**Spring** makes it possible to **access** a **bean** from the **application context** by using the `getBean()` method.

The method can receive as arguments:

- **Bean name**

- **Bean type**

- **Bean name and type**

- **Bean Constructor Parameters**

- **Bean Constructor Parameters and type**

By working with **multiple arguments**, the method provides **several ways** to **retrieve a bean**.

The following code uses the `getBean()` method with a **type argument**:

```java
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
    ApplicationContext context = SpringApplication.run(MainApplication.class, args);
    Animal dog = context.getBean(Dog.class);
    System.out.println("DOG: " + dog.getClass().getSimpleName());
    }
}
```

Executing the code would result in:

[image assetsSrc="Java-Spring-Boot-6.jpg" /]

[/slide]

[slide hideTitle]

# Scopes of Beans in the Spring Framework

[video src="https://videos.softuni.org/hls/Java/Java-Spring-Fundamentals/EN/Spring-Boot/18-bean-scopes-,1080p,720p,480p,360p,240p,.mp4/urlset/master.m3u8" poster="" /]


The **scope** of a **bean** sets the **rules for its usage**.

It defines where the bean is **visible** when it is **usable** and its **life cycle**.

In **Spring** there are the following **six** scopes for a **bean**:

- **Singleton**

- **Prototype**

- **Request**

- **Session**

- **Application**

- **Websocket**


## Singleton Scope

The **Singleton** scope is the **default** scope for a **bean**.

As the name suggests, this scope creates a **single bean** - **every request** for a **bean** with the "Singleton" scope would return the **same object**.

Anytime this **object** changes, all of the **bean references** will also change.

The following code defines a **bean** with a **singleton** scope:

```java
@Bean
@Scope("singleton") <- Can be ommited
public Employee employee() {
    return new Employee();
}
```


## Prototype Scope

The **Prototype** scope is the opposite of the **Singleton**.

Instead of returning the **same instance**, the **Prototype** scope returns a **different instance** on every **request**.

This is how to define a bean with the **prototype** scope:

[image assetsSrc="Java-Spring-Boot-7.png" /]

```java
@Bean
@Scope("prototype")
public Employee employee() {
    return new Employee();
}
```

## Bean Scope

The **Singleton** beans are **stateless** beans because they **cannot** carry **different state**.

However, the **Prototype** beans can **carry state**, as they point to **different instances**.

In other words, Singleton beans are state-less, while Prototype beans are state-full.


## Request Scope

The **Request** scope is used exclusively in **web applications**.

It creates a **different instance** for every **HTTP request**.

Here is how to define a bean with a **request** scope:

```java
@Bean
@RequestScope
public Employee employee() {
    return new Employee();
}
```


## Session Scope

The **Session** scope is the type used in a web context.

Unlike the **Request** scope, it creates a new bean on every **HTTP session**.

The following code is an example of a **session** scope bean:

```java
@Bean
@SessionScope
public Employee employee() {
    return new Employee();
}
```


## Application Scope

The **Application** scope creates **one** bean instance for the **ServletContext**.

**Application** scope makes the bean **accessible** to all **applications** in the **ServletContext**.

That makes them different from **Singleton** beans, which are limited to a **single** application.

This is how to create a bean with an **application** scope:

```java
@Bean
@ApplicationScope
public Employee employee() {
    return new Employee();
}
```


## WebSocket Scope

The **WebSocket** scope is another one that is **web-related**.

It also creates **one** instance of the bean, but in a **WebSocket session**.

The **bean instance** is accessible through that **session**.

The following code creates a **WebSocket** scope bean:

```java
@Bean
@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
public Employee employee() {
    return new Employee();
}
```

[/slide]

[slide hideTitle]

# Bean Lifecycle

[video src="https://videos.softuni.org/hls/Java/Java-Spring-Fundamentals/EN/Spring-Boot/22-bean-lifecycle-,1080p,720p,480p,360p,240p,.mp4/urlset/master.m3u8" poster="" /]

A **Spring Bean** goes through many phases from its **instantiation** to its **destruction**.

It receives **properties**, a **name**, and a **context**.

Then, it goes through **initialization** phases.

The following image illustrates the **full lifecycle** of a **bean**:

[image assetsSrc="Java-Spring-Boot-8.png" /]

[/slide]

[slide hideTitle]

# Bean Lifecycle Demo

Assume there is the following **bean**:

```java
@SpringBootApplication
public class MainApplication {

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(MainApplication.class, args);
        ((AbstractApplicationContext)context).close();
    }

    @Bean(destroyMethod = "destroy", initMethod = "init")
    public Employee getEmployee(){
        return new Employee();
    }
}
```

The following code creates **methods** that go through the **Instantiation**, **Initialization**, and **Destruction** of a **bean**:

```java
public class Assistant implements Employee {

    public Assistant() {
        System.out.println("Instantiation");
    }

    public void init(){
        System.out.println("Initializing..");
    }

    public void destroy(){
        System.out.println("Destroying..");
    }
}

```

[/slide]

[slide hideTitle]

# PostConstruct Annotation

**Spring** has **annotations** that execute actions **before** or **after** certain **lifecycle phases**.

One of these **annotations** is `@PostConstruct`.

It allows for **non-static** methods to be executed **once**, after the **initialization** of a **bean**.

For example, some **data** can be send to the **database** by using `@PostConstruct`:

```java
@Component
public class DbInit {
Â Â Â Â private final UserRepository userRepository;
    public DbUnit(UserRepository userRepository)
	{ this. userRepository = userRepository;}

Â Â Â Â @PostConstruct
Â Â Â Â private void postConstruct() {
Â Â Â Â Â Â Â Â User user = new User("user", "user password");
Â Â Â Â Â Â Â Â userRepository.save(user);
Â Â Â Â }
}
```

[/slide]

[slide hideTitle]

# PreDestroy Annotation

The `@PreDestroy` **annotation** runs a **non-static** method before a **Spring Bean** is **removed**.

It is the **last** available time to **run functions**, **associated** with a certain bean's **lifecycle**.

This **annotation** is used to **clear unused resources** before a **bean** is **removed** from the **application**.

Here is how to use `@PreDestroy`:

```java
@Component
public class UserRepository {
Â 
Â Â Â Â private DbConnection dbConnection;
Â Â Â Â @PreDestroy
Â Â Â Â public void preDestroy() {
Â Â Â Â Â Â Â Â dbConnection.close();
Â Â Â Â }
}
```

[/slide]

[slide hideTitle]

# PostConstruct & PreDestroy with Java 9+

The `@PostConstruct` and `@PreDestroy` **annotations** are part of **Java Enterprise Edition**.

However, **Java EE** was **deprecated** in **Java 9** and **removed** in **Java 11**.

Add the following **dependency** to use these **annotations**:

```java
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.3.2</version>
</dependency>
```


## BeanNameAware Interface

The `BeanNameAware` **interface** allows the object to access the **bean name**, defined in the **container**.

**Naming** a **bean** makes it possible to **look it up** by its **name** with the `getBean()` method.

Here is an example of a **bean** with a **name**:

```java
@Configuration
public class Config {
    @Bean (name = "RandomBeanName")
    public BeanName getBeanName() {
        return new BeanName();
    }
}
```

The following class has a method that **prints** the bean's name:

```java
public class BeanName implements BeanNameAware {
    @Override
    public void setBeanName(String beanName) {
        System.out.println(beanName);
    }
}
```


## BeanFactoryAware Interface

```java
public class MyBeanFactory implements BeanFactoryAware {
Â Â Â Â private BeanFactory beanFactory;Â 

Â Â Â Â @Override
Â Â Â Â public void setBeanFactory(BeanFactory beanFactory)throws BeansException {
Â Â Â Â Â Â Â Â this.beanFactory = beanFactory;
    }

Â Â Â Â public void getBeanName() {
Â Â Â Â Â Â Â Â BeanName beanName = beanFactory.getBean(BeanName.class);
Â Â Â Â Â Â Â Â System.out.println(beanFactory.isSingleton("RandomBeanName"));
Â Â Â Â }
}
```

[/slide]

[slide hideTitle]

# InitializingBean Interface

The `InitializingBean` **interface** is a lot like the `@PostConstruct` **annotation**.

They both **perform** certain **operations** after a **specific part** of the bean's **lifecycle** is finished.

The only difference is that the `afterPropertiesSet()` method is used, instead of **annotations**.

This is how to create a **class** that **implements** the `InitializingBean` **interface**:

```java
@Component
public class InitializingBeanExampleBean implements InitializingBean {
    private static final Logger LOG
      = Logger.getLogger(InitializingBeanExampleBean.class);

    @Autowired
    private Environment environment;

    @Override
    public void afterPropertiesSet() throws Exception {
        LOG.info(Arrays.asList(environment.getDefaultProfiles()));
    }
}
```


## DisposableBean Interface

The `DisposableBean` **interface** is one of the several ways to execute a **shutdown callback**.

It is similar to the `@PreDestroy` **annotation** but uses a `destroy()` **method** instead.

After the **bean** is **released** by the **container**, all the **custom logic** within the method will be **executed**.

The following code is an example of how to use the `DisposableBean` **interface**:

```java
@Component
public class BeanToBeDestroyed implements DisposableBean {

    @Override
    public void destroy() throws Exception {
        System.out.println(
          "Callback triggered - DisposableBean.");
    }
}
```

[/slide]

[slide hideTitle]

# Common Application Properties


[video src="https://videos.softuni.org/hls/Java/Java-Spring-Fundamentals/EN/Spring-Boot/31-common-application-properties-,1080p,720p,480p,360p,240p,.mp4/urlset/master.m3u8" poster="" /]

All the **properties** for the **Spring Boot** application are set **externally**.

This makes the **configuration** "portable" as it could be used **multiple times** in **different environments**.

The `application.properties` file is where these **properties** are **specified**.

Some **additional properties** can come from `.jar` files.

**Spring Boot** also makes it possible to define **custom properties**.

For more information, visit the official [documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html).

The following code is an example of an `application.properties` file and what can be defined inside it:

```java
spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/thymeleaf_adv_lab_exam_db?createDatabaseIfNotExist=true
spring.datasource.username=root
spring.datasource.password=12345
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql = TRUE
spring.jpa.hibernate.ddl-auto = update
spring.jpa.open-in-view=false
logging.level.org = WARN
logging.level.blog = WARN
logging.level.org.hibernate.SQL = DEBUG
logging.level.org.hibernate.type.descriptor = TRACE
server.port=8000
```

[/slide]